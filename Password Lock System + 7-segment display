module password_lock_system (
    input clk,
    input reset,
    input [3:0] entered_pass,
    output unlock,
    output locked,
    output [1:0] attempts,
    output [6:0] seg0, seg1, seg2, seg3
);

    wire [1:0] state;

   
    password_lock core (
        .clk(clk),
        .reset(reset),
        .entered_pass(entered_pass),
        .unlock(unlock),
        .locked(locked),
        .attempts(attempts),
        .state(state)
    );

   
    display_controller disp (
        .state(state),
        .seg0(seg0),
        .seg1(seg1),
        .seg2(seg2),
        .seg3(seg3)
    );

endmodule

module password_lock (
    input clk,
    input reset,
    input [3:0] entered_pass,
    output reg unlock,
    output reg locked,
    output reg [1:0] attempts,
    output reg [1:0] state
);
    parameter PASSWORD = 4'b1010;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            unlock <= 0;
            locked <= 0;
            attempts <= 0;
            state <= 2'b00; // WAIT
        end
        else if (!locked) begin
            if (entered_pass == PASSWORD) begin
                unlock <= 1;
                locked <= 0;
                attempts <= 0;
                state <= 2'b01; // OPEN
            end else begin
                attempts <= attempts + 1;
                unlock <= 0;
                if (attempts == 2) begin
                    locked <= 1;
                    state <= 2'b10; // LOCK
                end else begin
                    state <= 2'b00; // WAIT
                end
            end
        end
    end
endmodule


module display_controller (
    input [1:0] state,
    output [6:0] seg0, seg1, seg2, seg3
);
    reg [7:0] chars[3:0];

    always @(*) begin
        case (state)
            2'b00: begin chars[0] = "W"; chars[1] = "A"; chars[2] = "I"; chars[3] = "T"; end
            2'b01: begin chars[0] = "O"; chars[1] = "P"; chars[2] = "E"; chars[3] = "N"; end
            2'b10: begin chars[0] = "L"; chars[1] = "O"; chars[2] = "C"; chars[3] = "K"; end
            default: begin chars[0] = " "; chars[1] = " "; chars[2] = " "; chars[3] = " "; end
        endcase
    end

    char_to_segment c0(.char(chars[0]), .seg(seg0));
    char_to_segment c1(.char(chars[1]), .seg(seg1));
    char_to_segment c2(.char(chars[2]), .seg(seg2));
    char_to_segment c3(.char(chars[3]), .seg(seg3));
endmodule


module char_to_segment (
    input [7:0] char,
    output reg [6:0] seg
);
    always @(*) begin
        case (char)
            "O": seg = 7'b0000001;
            "P": seg = 7'b0001100;
            "E": seg = 7'b0110000;
            "N": seg = 7'b1000100;
            "W": seg = 7'b1111100;
            "A": seg = 7'b0001000;
            "I": seg = 7'b1111001;
            "T": seg = 7'b0110000;
            "L": seg = 7'b1110001;
            "C": seg = 7'b0110001;
            "K": seg = 7'b1000100;
            default: seg = 7'b1111111; // blank
        endcase
    end
endmodule
